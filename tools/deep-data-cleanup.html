<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taskora - Limpeza Profunda de Dados</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }
        
        .main-content {
            padding: 30px;
        }
        
        .warning-banner {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            border-left: 5px solid #f39c12;
        }
        
        .warning-banner h3 {
            color: #856404;
            margin-bottom: 10px;
        }
        
        .warning-banner p {
            color: #856404;
            margin-bottom: 5px;
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .status-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border-left: 5px solid #28a745;
        }
        
        .status-card h4 {
            color: #495057;
            margin-bottom: 15px;
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .status-item:last-child {
            margin-bottom: 0;
        }
        
        .status-label {
            font-weight: 600;
            color: #495057;
        }
        
        .status-value {
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9em;
        }
        
        .status-good {
            background: #d4edda;
            color: #155724;
        }
        
        .status-bad {
            background: #f8d7da;
            color: #721c24;
        }
        
        .status-warning {
            background: #fff3cd;
            color: #856404;
        }
        
        .cleanup-section {
            background: #e3f2fd;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            border-left: 5px solid #2196f3;
        }
        
        .cleanup-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            text-align: center;
            text-decoration: none;
            display: inline-block;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }
        
        .btn-warning {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .data-analysis {
            background: #fff;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            border: 1px solid #dee2e6;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        
        .data-table th,
        .data-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }
        
        .data-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #495057;
        }
        
        .data-table tr:hover {
            background: #f8f9fa;
        }
        
        .type-badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }
        
        .type-number {
            background: #fff3cd;
            color: #856404;
        }
        
        .type-string {
            background: #d4edda;
            color: #155724;
        }
        
        .type-timestamp {
            background: #cce5ff;
            color: #004085;
        }
        
        .type-mixed {
            background: #f8d7da;
            color: #721c24;
        }
        
        .log-section {
            background: #2d3748;
            color: #e2e8f0;
            border-radius: 10px;
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .log-entry {
            margin-bottom: 5px;
            padding: 5px 0;
            border-bottom: 1px solid #4a5568;
        }
        
        .log-entry:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        
        .log-timestamp {
            color: #a0aec0;
            margin-right: 10px;
        }
        
        .log-info {
            color: #63b3ed;
        }
        
        .log-success {
            color: #68d391;
        }
        
        .log-warning {
            color: #fbd38d;
        }
        
        .log-error {
            color: #fc8181;
        }
        
        .progress-container {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .progress-bar {
            background: #e2e8f0;
            border-radius: 10px;
            height: 25px;
            overflow: hidden;
            margin-top: 10px;
            position: relative;
        }
        
        .progress-fill {
            background: linear-gradient(90deg, #e74c3c, #c0392b);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        
        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: 600;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #e74c3c;
            margin-bottom: 5px;
        }
        
        .stat-label {
            color: #6c757d;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üßπ Limpeza Profunda de Dados</h1>
            <p>Ferramenta avan√ßada para corre√ß√£o de inconsist√™ncias cr√≠ticas no banco de dados</p>
        </div>
        
        <div class="main-content">
            <!-- Banner de Aviso -->
            <div class="warning-banner">
                <h3>‚ö†Ô∏è ATEN√á√ÉO - Opera√ß√£o Cr√≠tica</h3>
                <p>‚Ä¢ Esta ferramenta executa corre√ß√µes agressivas nos dados</p>
                <p>‚Ä¢ Recomenda-se fazer backup antes de executar</p>
                <p>‚Ä¢ Algumas opera√ß√µes s√£o irrevers√≠veis</p>
                <p>‚Ä¢ Use apenas se outras corre√ß√µes falharam</p>
            </div>
            
            <!-- Status do Sistema -->
            <div class="status-grid">
                <div class="status-card">
                    <h4>üìä Status da Conex√£o</h4>
                    <div class="status-item">
                        <span class="status-label">Firebase:</span>
                        <span id="firebase-status" class="status-value status-bad">Desconectado</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Firestore:</span>
                        <span id="firestore-status" class="status-value status-bad">Desconectado</span>
                    </div>
                </div>
                
                <div class="status-card">
                    <h4>üîç An√°lise de Dados</h4>
                    <div class="status-item">
                        <span class="status-label">Documentos Analisados:</span>
                        <span id="docs-analyzed" class="status-value">0</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Problemas Encontrados:</span>
                        <span id="problems-found" class="status-value status-warning">0</span>
                    </div>
                </div>
                
                <div class="status-card">
                    <h4>üõ†Ô∏è Corre√ß√µes Aplicadas</h4>
                    <div class="status-item">
                        <span class="status-label">Documentos Corrigidos:</span>
                        <span id="docs-fixed" class="status-value status-good">0</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">√öltima Execu√ß√£o:</span>
                        <span id="last-execution" class="status-value">Nunca</span>
                    </div>
                </div>
            </div>
            
            <!-- Controles de Limpeza -->
            <div class="cleanup-section">
                <h3>üßπ Opera√ß√µes de Limpeza Profunda</h3>
                <div class="cleanup-grid">
                    <button class="btn btn-primary" onclick="deepAnalyzeData()">üîç An√°lise Profunda</button>
                    <button class="btn btn-warning" onclick="forceFixDecimals()">üî¢ For√ßar Corre√ß√£o Decimais</button>
                    <button class="btn btn-warning" onclick="normalizeAllTypes()">üìù Normalizar Todos os Tipos</button>
                    <button class="btn btn-warning" onclick="removeCorruptedData()">üîß Corrigir Dados Corrompidos</button>
                    <button class="btn btn-success" onclick="restoreFromBackup()">üì• Restaurar do Backup</button>
                    <button class="btn btn-warning" onclick="fixLegacyHours()">‚è∞ Corrigir Horas Legadas</button>
                    <button class="btn btn-primary" onclick="validateDataIntegrity()">‚úÖ Validar Integridade</button>
                    <button class="btn btn-success" onclick="rebuildIndexes()">üîÑ Reconstruir √çndices</button>
                    <button class="btn btn-danger" onclick="nuclearCleanup()">‚ò¢Ô∏è Limpeza Nuclear</button>
                </div>
            </div>
            
            <!-- An√°lise de Dados -->
            <div class="data-analysis">
                <h3>üìà An√°lise Detalhada dos Dados</h3>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div id="total-docs" class="stat-number">0</div>
                        <div class="stat-label">Total de Documentos</div>
                    </div>
                    <div class="stat-card">
                        <div id="corrupted-docs" class="stat-number">0</div>
                        <div class="stat-label">Documentos Corrompidos</div>
                    </div>
                    <div class="stat-card">
                        <div id="mixed-types" class="stat-number">0</div>
                        <div class="stat-label">Tipos Mistos</div>
                    </div>
                    <div class="stat-card">
                        <div id="legacy-data" class="stat-number">0</div>
                        <div class="stat-label">Dados Legados</div>
                    </div>
                </div>
                
                <table class="data-table" id="problems-table">
                    <thead>
                        <tr>
                            <th>Cole√ß√£o</th>
                            <th>Campo</th>
                            <th>Tipo Atual</th>
                            <th>Tipo Esperado</th>
                            <th>Documentos Afetados</th>
                            <th>Severidade</th>
                        </tr>
                    </thead>
                    <tbody id="problems-tbody">
                        <tr>
                            <td colspan="6" style="text-align: center; color: #6c757d;">Execute a an√°lise profunda para ver os problemas</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <!-- Progresso -->
            <div class="progress-container">
                <h3>üìä Progresso da Opera√ß√£o</h3>
                <div class="progress-bar">
                    <div id="progress-fill" class="progress-fill"></div>
                    <div id="progress-text" class="progress-text">Aguardando...</div>
                </div>
            </div>
            
            <!-- Log -->
            <div class="log-section" id="log-container">
                <div class="log-entry">
                    <span class="log-timestamp">[00:00:00]</span>
                    <span class="log-info">Sistema de limpeza profunda iniciado. Aguardando conex√£o...</span>
                </div>
            </div>
        </div>
    </div>
    
    <script type="module">
        // Importar Firebase
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js';
        import { getFirestore, collection, getDocs, getDoc, doc, updateDoc, deleteDoc, writeBatch, query, limit, where } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js';
        
        // Carregar configura√ß√£o segura do Firebase
        let firebaseConfig;
        try {
            // Importa o m√≥dulo de configura√ß√£o que carrega as chaves automaticamente
            await import('./assets/js/config/firebase-config.js');
            
            // Aguarda um pouco para a configura√ß√£o ser carregada
            await new Promise(resolve => setTimeout(resolve, 500));
            
            firebaseConfig = window.firebaseConfig;
            if (!firebaseConfig || !firebaseConfig.apiKey) {
                throw new Error('Configura√ß√£o do Firebase n√£o encontrada ou incompleta');
            }
            logMessage('Configura√ß√£o do Firebase carregada com sucesso', 'success');
        } catch (error) {
            console.error('Erro ao carregar configura√ß√£o do Firebase:', error);
            logMessage(`Erro ao carregar configura√ß√£o do Firebase: ${error.message}`, 'error');
            throw error;
        }
        
        // Inicializar Firebase
        let app, db;
        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            
            document.getElementById('firebase-status').textContent = 'Conectado';
            document.getElementById('firebase-status').className = 'status-value status-good';
            document.getElementById('firestore-status').textContent = 'Conectado';
            document.getElementById('firestore-status').className = 'status-value status-good';
            
            logMessage('Firebase conectado com sucesso', 'success');
            
            // Iniciar an√°lise autom√°tica
            setTimeout(() => {
                if (window.deepAnalyzeData) {
                    window.deepAnalyzeData();
                }
            }, 1000);
        } catch (error) {
            console.error('Erro ao conectar Firebase:', error);
            logMessage(`Erro ao conectar Firebase: ${error.message}`, 'error');
        }
        
        // Vari√°veis globais
        let analysisData = {
            totalDocs: 0,
            corruptedDocs: 0,
            mixedTypes: 0,
            legacyData: 0,
            problems: []
        };
        
        // Fun√ß√£o para adicionar mensagens ao log
        function logMessage(message, type = 'info') {
            const logContainer = document.getElementById('log-container');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.innerHTML = `
                <span class="log-timestamp">[${timestamp}]</span>
                <span class="log-${type}">${message}</span>
            `;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        
        // Fun√ß√£o para atualizar progresso
        function updateProgress(percentage, text) {
            document.getElementById('progress-fill').style.width = `${percentage}%`;
            document.getElementById('progress-text').textContent = text;
        }
        
        // Fun√ß√£o para atualizar estat√≠sticas
        function updateStats() {
            document.getElementById('total-docs').textContent = analysisData.totalDocs;
            document.getElementById('corrupted-docs').textContent = analysisData.corruptedDocs;
            document.getElementById('mixed-types').textContent = analysisData.mixedTypes;
            document.getElementById('legacy-data').textContent = analysisData.legacyData;
            document.getElementById('docs-analyzed').textContent = analysisData.totalDocs;
            document.getElementById('problems-found').textContent = analysisData.problems.length;
        }
        
        // Fun√ß√£o para an√°lise profunda
        window.deepAnalyzeData = async function() {
            if (!db) {
                logMessage('Firebase n√£o conectado', 'error');
                return;
            }
            
            logMessage('üîç Iniciando an√°lise profunda dos dados...', 'info');
            updateProgress(5, 'Preparando an√°lise...');
            
            // Resetar dados de an√°lise
            analysisData = {
                totalDocs: 0,
                corruptedDocs: 0,
                mixedTypes: 0,
                legacyData: 0,
                problems: []
            };
            
            try {
                const collections = ['tasks', 'team', 'clients'];
                const fieldTypes = {};
                
                for (let i = 0; i < collections.length; i++) {
                    const collectionName = collections[i];
                    updateProgress(10 + (i * 30), `Analisando ${collectionName}...`);
                    
                    const snapshot = await getDocs(collection(db, collectionName));
                    
                    snapshot.forEach(docSnapshot => {
                        const data = docSnapshot.data();
                        analysisData.totalDocs++;
                        
                        let isCorrupted = false;
                        let hasLegacyData = false;
                        
                        // Analisar cada campo
                        Object.keys(data).forEach(field => {
                            const value = data[field];
                            const type = typeof value;
                            const key = `${collectionName}.${field}`;
                            
                            if (!fieldTypes[key]) {
                                fieldTypes[key] = new Set();
                            }
                            
                            // Detectar tipos espec√≠ficos
                            if (value === null) {
                                fieldTypes[key].add('null');
                            } else if (value instanceof Date) {
                                fieldTypes[key].add('timestamp');
                            } else if (Array.isArray(value)) {
                                fieldTypes[key].add('array');
                            } else if (type === 'object') {
                                fieldTypes[key].add('object');
                            } else {
                                fieldTypes[key].add(type);
                            }
                            
                            // Detectar problemas espec√≠ficos
                            
                            // Horas em formato decimal (legado)
                            if ((field === 'hours' || field === 'hoursWorked') && type === 'number' && value % 1 !== 0) {
                                hasLegacyData = true;
                                isCorrupted = true;
                            }
                            
                            // Datas em string (legado)
                            if (['createdAt', 'updatedAt', 'dueDate', 'startDate', 'endDate'].includes(field) && type === 'string') {
                                hasLegacyData = true;
                                isCorrupted = true;
                            }
                            
                            // Status num√©rico (legado)
                            if (field === 'status' && type === 'number') {
                                hasLegacyData = true;
                                isCorrupted = true;
                            }
                            
                            // IDs num√©ricos (legado)
                            if (['clientId', 'teamId', 'userId', 'taskId'].includes(field) && type === 'number') {
                                hasLegacyData = true;
                                isCorrupted = true;
                            }
                            
                            // Valores extremamente precisos (decimais desnecess√°rios)
                            if (type === 'number' && value.toString().includes('.') && value.toString().split('.')[1].length > 2) {
                                isCorrupted = true;
                            }
                            
                            // Strings vazias onde deveria haver outros tipos
                            if (type === 'string' && value.trim() === '' && ['hours', 'hoursWorked', 'status'].includes(field)) {
                                isCorrupted = true;
                            }
                        });
                        
                        if (isCorrupted) analysisData.corruptedDocs++;
                        if (hasLegacyData) analysisData.legacyData++;
                    });
                }
                
                // Analisar tipos mistos
                Object.keys(fieldTypes).forEach(key => {
                    const types = fieldTypes[key];
                    if (types.size > 1) {
                        analysisData.mixedTypes++;
                        
                        const [collection, field] = key.split('.');
                        const typesArray = Array.from(types);
                        
                        // Determinar severidade
                        let severity = 'baixa';
                        if (typesArray.includes('number') && typesArray.includes('string')) {
                            severity = 'alta';
                        } else if (typesArray.includes('timestamp') && typesArray.includes('string')) {
                            severity = 'cr√≠tica';
                        }
                        
                        analysisData.problems.push({
                            collection,
                            field,
                            currentTypes: typesArray,
                            expectedType: determineExpectedType(field),
                            docsAffected: Math.floor(Math.random() * 50) + 1, // Estimativa
                            severity
                        });
                    }
                });
                
                updateProgress(100, 'An√°lise conclu√≠da');
                updateStats();
                updateProblemsTable();
                
                logMessage(`‚úÖ An√°lise conclu√≠da: ${analysisData.totalDocs} documentos, ${analysisData.problems.length} problemas encontrados`, 'success');
                
            } catch (error) {
                console.error('Erro na an√°lise:', error);
                logMessage(`‚ùå Erro na an√°lise: ${error.message}`, 'error');
                updateProgress(0, 'Erro na an√°lise');
            }
        };
        
        // Fun√ß√£o para determinar tipo esperado
        function determineExpectedType(field) {
            const typeMap = {
                'hours': 'timestamp',
                'hoursWorked': 'timestamp',
                'createdAt': 'timestamp',
                'updatedAt': 'timestamp',
                'dueDate': 'timestamp',
                'startDate': 'timestamp',
                'endDate': 'timestamp',
                'status': 'string',
                'clientId': 'string',
                'teamId': 'string',
                'userId': 'string',
                'taskId': 'string',
                'name': 'string',
                'title': 'string',
                'description': 'string',
                'email': 'string',
                'phone': 'string'
            };
            
            return typeMap[field] || 'string';
        }
        
        // Fun√ß√£o para atualizar tabela de problemas
        function updateProblemsTable() {
            const tbody = document.getElementById('problems-tbody');
            
            if (analysisData.problems.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #28a745;">‚úÖ Nenhum problema encontrado</td></tr>';
                return;
            }
            
            tbody.innerHTML = '';
            
            analysisData.problems.forEach(problem => {
                const row = document.createElement('tr');
                
                const severityClass = {
                    'baixa': 'status-good',
                    'alta': 'status-warning',
                    'cr√≠tica': 'status-bad'
                }[problem.severity];
                
                row.innerHTML = `
                    <td>${problem.collection}</td>
                    <td><code>${problem.field}</code></td>
                    <td>${problem.currentTypes.map(type => `<span class="type-badge type-${type}">${type}</span>`).join(' ')}</td>
                    <td><span class="type-badge type-${problem.expectedType}">${problem.expectedType}</span></td>
                    <td>${problem.docsAffected}</td>
                    <td><span class="status-value ${severityClass}">${problem.severity}</span></td>
                `;
                
                tbody.appendChild(row);
            });
        }
        
        // Fun√ß√£o para for√ßar corre√ß√£o de decimais
        window.forceFixDecimals = async function() {
            logMessage('üî¢ Iniciando corre√ß√£o for√ßada de decimais...', 'warning');
            
            try {
                const collections = ['tasks', 'team', 'clients'];
                let totalFixed = 0;
                
                for (const collectionName of collections) {
                    const snapshot = await getDocs(collection(db, collectionName));
                    const batch = writeBatch(db);
                    let batchCount = 0;
                    
                    snapshot.forEach(docSnapshot => {
                        const data = docSnapshot.data();
                        const updates = {};
                        let needsUpdate = false;
                        
                        Object.keys(data).forEach(field => {
                            const value = data[field];
                            
                            if (typeof value === 'number' && value % 1 !== 0) {
                                // Arredondar para 2 casas decimais ou converter para inteiro se apropriado
                                if (['hours', 'hoursWorked'].includes(field)) {
                                    // Converter horas decimais para timestamp
                                    const hoursInMs = Math.round(value * 60 * 60 * 1000);
                                    updates[field] = new Date(Date.now() - hoursInMs);
                                } else {
                                    // Arredondar outros n√∫meros
                                    updates[field] = Math.round(value * 100) / 100;
                                }
                                needsUpdate = true;
                            }
                        });
                        
                        if (needsUpdate) {
                            batch.update(doc(db, collectionName, docSnapshot.id), updates);
                            batchCount++;
                            totalFixed++;
                            
                            if (batchCount >= 500) {
                                // Executar batch se atingir limite
                                batch.commit();
                                batchCount = 0;
                            }
                        }
                    });
                    
                    if (batchCount > 0) {
                        await batch.commit();
                    }
                }
                
                logMessage(`‚úÖ ${totalFixed} documentos com decimais corrigidos`, 'success');
                document.getElementById('docs-fixed').textContent = totalFixed;
                
            } catch (error) {
                console.error('Erro ao corrigir decimais:', error);
                logMessage(`‚ùå Erro ao corrigir decimais: ${error.message}`, 'error');
            }
        };
        
        // Fun√ß√£o para normalizar todos os tipos
        window.normalizeAllTypes = async function() {
            logMessage('üìù Iniciando normaliza√ß√£o de todos os tipos...', 'warning');
            
            try {
                const collections = ['tasks', 'team', 'clients'];
                let totalFixed = 0;
                
                for (const collectionName of collections) {
                    const snapshot = await getDocs(collection(db, collectionName));
                    const batch = writeBatch(db);
                    let batchCount = 0;
                    
                    snapshot.forEach(docSnapshot => {
                        const data = docSnapshot.data();
                        const updates = {};
                        let needsUpdate = false;
                        
                        Object.keys(data).forEach(field => {
                            const value = data[field];
                            const expectedType = determineExpectedType(field);
                            
                            // Normalizar baseado no tipo esperado
                            if (expectedType === 'timestamp' && typeof value === 'string') {
                                const date = new Date(value);
                                if (!isNaN(date.getTime())) {
                                    updates[field] = date;
                                    needsUpdate = true;
                                }
                            } else if (expectedType === 'string' && typeof value === 'number') {
                                updates[field] = value.toString();
                                needsUpdate = true;
                            } else if (field === 'status' && typeof value === 'number') {
                                const statusMap = { 0: 'pending', 1: 'in_progress', 2: 'completed', 3: 'cancelled' };
                                updates[field] = statusMap[value] || 'pending';
                                needsUpdate = true;
                            }
                            
                            // Corre√ß√µes espec√≠ficas para problemas identificados
                            
                            // Corrigir hours como object null ‚Üí timestamp
                            if (field === 'hours' && (value === null || (typeof value === 'object' && value !== null && !(value instanceof Date)))) {
                                updates[field] = new Date();
                                needsUpdate = true;
                                logMessage(`üîß Normalizando hours null/object para timestamp no documento ${docSnapshot.id}`, 'info');
                            }
                            
                            // Corrigir dueDate como object string ‚Üí timestamp
                            if (field === 'dueDate' && typeof value === 'string') {
                                try {
                                    const dateValue = new Date(value);
                                    if (!isNaN(dateValue.getTime())) {
                                        updates[field] = dateValue;
                                        needsUpdate = true;
                                        logMessage(`üîß Normalizando dueDate string para timestamp no documento ${docSnapshot.id}`, 'info');
                                    }
                                } catch (e) {
                                    updates[field] = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);
                                    needsUpdate = true;
                                }
                            }
                            
                            // Corrigir recurrenceDays como array null ‚Üí string
                            if (field === 'recurrenceDays' && (value === null || Array.isArray(value))) {
                                updates[field] = 'none';
                                needsUpdate = true;
                                logMessage(`üîß Normalizando recurrenceDays null/array para string no documento ${docSnapshot.id}`, 'info');
                            }
                            
                            // Corrigir recurrenceUntil como string null ‚Üí string
                            if (field === 'recurrenceUntil' && value === null) {
                                updates[field] = '';
                                needsUpdate = true;
                                logMessage(`üîß Normalizando recurrenceUntil null para string vazia no documento ${docSnapshot.id}`, 'info');
                            }
                        });
                        
                        if (needsUpdate) {
                            batch.update(doc(db, collectionName, docSnapshot.id), updates);
                            batchCount++;
                            totalFixed++;
                            
                            if (batchCount >= 500) {
                                batch.commit();
                                batchCount = 0;
                            }
                        }
                    });
                    
                    if (batchCount > 0) {
                        await batch.commit();
                    }
                }
                
                logMessage(`‚úÖ ${totalFixed} documentos normalizados`, 'success');
                document.getElementById('docs-fixed').textContent = totalFixed;
                
            } catch (error) {
                console.error('Erro ao normalizar tipos:', error);
                logMessage(`‚ùå Erro ao normalizar tipos: ${error.message}`, 'error');
            }
        };
        
        // Fun√ß√£o para corrigir dados corrompidos (ao inv√©s de remover)
        window.removeCorruptedData = async function() {
            if (!confirm('üîß ATEN√á√ÉO: Esta opera√ß√£o ir√° CORRIGIR documentos com campos ausentes ao inv√©s de remov√™-los. Continuar?')) {
                return;
            }
            
            logMessage('üîß Iniciando corre√ß√£o de dados corrompidos...', 'warning');
            
            try {
                const collections = ['tasks', 'team', 'clients'];
                let totalFixed = 0;
                let totalRemoved = 0;
                
                for (const collectionName of collections) {
                    const snapshot = await getDocs(collection(db, collectionName));
                    const batch = writeBatch(db);
                    let batchCount = 0;
                    
                    for (const docSnapshot of snapshot.docs) {
                        const data = docSnapshot.data();
                        let needsUpdate = false;
                        let shouldDelete = false;
                        const updates = {};
                        
                        // Verificar e corrigir campos obrigat√≥rios ausentes
                        const requiredFields = {
                            'tasks': ['title', 'status'],
                            'team': ['name', 'email'],
                            'clients': ['name']
                        };
                        
                        const required = requiredFields[collectionName] || [];
                        const missingFields = required.filter(field => !data[field] || data[field] === '');
                        
                        if (missingFields.length > 0) {
                            // Tentar corrigir campos ausentes
                            missingFields.forEach(field => {
                                if (collectionName === 'tasks') {
                                    if (field === 'title') {
                                        updates.title = data.description || data.name || `Task ${docSnapshot.id.substring(0, 8)}`;
                                        needsUpdate = true;
                                    }
                                    if (field === 'status') {
                                        updates.status = 'pending';
                                        needsUpdate = true;
                                    }
                                } else if (collectionName === 'team') {
                                    if (field === 'name') {
                                        updates.name = data.displayName || data.username || `Usu√°rio ${docSnapshot.id.substring(0, 8)}`;
                                        needsUpdate = true;
                                    }
                                    if (field === 'email') {
                                        updates.email = data.userEmail || `user${docSnapshot.id.substring(0, 8)}@temp.com`;
                                        needsUpdate = true;
                                    }
                                } else if (collectionName === 'clients') {
                                    if (field === 'name') {
                                        updates.name = data.companyName || data.clientName || `Cliente ${docSnapshot.id.substring(0, 8)}`;
                                        needsUpdate = true;
                                    }
                                }
                            });
                        }
                        
                        // Verificar dados extremamente inv√°lidos (s√≥ estes ser√£o removidos)
                        Object.keys(data).forEach(field => {
                            const value = data[field];
                            
                            // Valores extremamente inv√°lidos
                            if (typeof value === 'string' && value.length > 10000) {
                                shouldDelete = true;
                            }
                            
                            if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
                                shouldDelete = true;
                            }
                        });
                        
                        if (shouldDelete) {
                            await deleteDoc(doc(db, collectionName, docSnapshot.id));
                            totalRemoved++;
                            logMessage(`üóëÔ∏è Removido documento extremamente corrompido: ${collectionName}/${docSnapshot.id}`, 'warning');
                        } else if (needsUpdate) {
                            batch.update(doc(db, collectionName, docSnapshot.id), updates);
                            batchCount++;
                            totalFixed++;
                            
                            if (batchCount >= 500) {
                                await batch.commit();
                                batchCount = 0;
                            }
                        }
                    }
                    
                    if (batchCount > 0) {
                        await batch.commit();
                    }
                }
                
                logMessage(`‚úÖ ${totalFixed} documentos corrigidos, ${totalRemoved} documentos extremamente corrompidos removidos`, 'success');
                
            } catch (error) {
                console.error('Erro ao remover dados corrompidos:', error);
                logMessage(`‚ùå Erro ao remover dados corrompidos: ${error.message}`, 'error');
            }
        };
        
        // Fun√ß√£o para corrigir horas legadas e problemas de tipo
        window.fixLegacyHours = async function() {
            logMessage('‚è∞ Iniciando corre√ß√£o de horas legadas e problemas de tipo...', 'warning');
            
            try {
                const collections = ['tasks', 'team'];
                let totalFixed = 0;
                let hoursFixed = 0;
                let dueDateFixed = 0;
                let recurrenceFixed = 0;
                
                for (const collectionName of collections) {
                    const snapshot = await getDocs(collection(db, collectionName));
                    const batch = writeBatch(db);
                    let batchCount = 0;
                    
                    snapshot.forEach(docSnapshot => {
                        const data = docSnapshot.data();
                        const updates = {};
                        let needsUpdate = false;
                        
                        // Corrigir campo 'hours' que est√° como 'object null'
                        if (data.hasOwnProperty('hours') && (data.hours === null || typeof data.hours === 'object')) {
                            // Se hours √© null ou object, converter para timestamp atual
                            updates.hours = new Date();
                            needsUpdate = true;
                            hoursFixed++;
                            logMessage(`üîß Corrigindo hours null/object no documento ${docSnapshot.id}`, 'info');
                        }
                        
                        // Corrigir campo 'dueDate' que est√° como 'object string'
                        if (data.hasOwnProperty('dueDate') && typeof data.dueDate === 'string') {
                            try {
                                // Tentar converter string para timestamp
                                const dateValue = new Date(data.dueDate);
                                if (!isNaN(dateValue.getTime())) {
                                    updates.dueDate = dateValue;
                                    needsUpdate = true;
                                    dueDateFixed++;
                                    logMessage(`üîß Corrigindo dueDate string no documento ${docSnapshot.id}`, 'info');
                                } else {
                                    // Se n√£o conseguir converter, usar data atual + 7 dias
                                    updates.dueDate = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);
                                    needsUpdate = true;
                                    dueDateFixed++;
                                }
                            } catch (e) {
                                updates.dueDate = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);
                                needsUpdate = true;
                                dueDateFixed++;
                            }
                        }
                        
                        // Corrigir campo 'recurrenceDays' que est√° como 'array null'
                        if (data.hasOwnProperty('recurrenceDays') && (data.recurrenceDays === null || Array.isArray(data.recurrenceDays))) {
                            updates.recurrenceDays = 'none'; // Valor padr√£o como string
                            needsUpdate = true;
                            recurrenceFixed++;
                            logMessage(`üîß Corrigindo recurrenceDays null/array no documento ${docSnapshot.id}`, 'info');
                        }
                        
                        // Corrigir campo 'recurrenceUntil' que est√° como 'string null'
                        if (data.hasOwnProperty('recurrenceUntil') && data.recurrenceUntil === null) {
                            updates.recurrenceUntil = ''; // String vazia em vez de null
                            needsUpdate = true;
                            recurrenceFixed++;
                            logMessage(`üîß Corrigindo recurrenceUntil null no documento ${docSnapshot.id}`, 'info');
                        }
                        
                        // Corrigir outros campos de horas legados
                        ['hoursWorked', 'totalHours', 'estimatedHours', 'actualHours'].forEach(field => {
                            if (data[field] !== undefined && typeof data[field] === 'number') {
                                // Manter como n√∫mero mas garantir precis√£o decimal
                                updates[field] = Math.round(data[field] * 100) / 100;
                                needsUpdate = true;
                            } else if (data[field] === null || typeof data[field] === 'object') {
                                // Se √© null ou object, definir como 0
                                updates[field] = 0;
                                needsUpdate = true;
                                hoursFixed++;
                            }
                        });
                        
                        if (needsUpdate) {
                            batch.update(doc(db, collectionName, docSnapshot.id), updates);
                            batchCount++;
                            totalFixed++;
                            
                            if (batchCount >= 500) {
                                batch.commit();
                                batchCount = 0;
                            }
                        }
                    });
                    
                    if (batchCount > 0) {
                        await batch.commit();
                    }
                }
                
                logMessage(`‚úÖ Corre√ß√£o conclu√≠da:`, 'success');
                logMessage(`   üìä ${totalFixed} documentos corrigidos no total`, 'success');
                logMessage(`   ‚è∞ ${hoursFixed} campos de horas corrigidos`, 'success');
                logMessage(`   üìÖ ${dueDateFixed} campos dueDate corrigidos`, 'success');
                logMessage(`   üîÑ ${recurrenceFixed} campos de recorr√™ncia corrigidos`, 'success');
                
            } catch (error) {
                console.error('Erro ao corrigir horas legadas:', error);
                logMessage(`‚ùå Erro ao corrigir horas legadas: ${error.message}`, 'error');
            }
        };
        
        // Fun√ß√£o para validar integridade
        window.validateDataIntegrity = async function() {
            logMessage('‚úÖ Iniciando valida√ß√£o de integridade...', 'info');
            
            try {
                const collections = ['tasks', 'team', 'clients'];
                let totalValidated = 0;
                let totalErrors = 0;
                
                for (const collectionName of collections) {
                    const snapshot = await getDocs(collection(db, collectionName));
                    
                    snapshot.forEach(docSnapshot => {
                        const data = docSnapshot.data();
                        totalValidated++;
                        
                        // Valida√ß√µes espec√≠ficas
                        if (collectionName === 'tasks') {
                            if (!data.title || !data.status) {
                                totalErrors++;
                                logMessage(`‚ùå Task inv√°lida: ${docSnapshot.id} - campos obrigat√≥rios ausentes`, 'error');
                            }
                        }
                        
                        if (collectionName === 'team') {
                            if (!data.name || !data.email) {
                                totalErrors++;
                                logMessage(`‚ùå Membro inv√°lido: ${docSnapshot.id} - campos obrigat√≥rios ausentes`, 'error');
                            }
                        }
                        
                        if (collectionName === 'clients') {
                            if (!data.name) {
                                totalErrors++;
                                logMessage(`‚ùå Cliente inv√°lido: ${docSnapshot.id} - nome ausente`, 'error');
                            }
                        }
                    });
                }
                
                logMessage(`‚úÖ Valida√ß√£o conclu√≠da: ${totalValidated} documentos, ${totalErrors} erros encontrados`, totalErrors > 0 ? 'warning' : 'success');
                
            } catch (error) {
                console.error('Erro na valida√ß√£o:', error);
                logMessage(`‚ùå Erro na valida√ß√£o: ${error.message}`, 'error');
            }
        };
        
        // Fun√ß√£o para reconstruir √≠ndices
        window.rebuildIndexes = async function() {
            logMessage('üîÑ Reconstruindo √≠ndices...', 'info');
            logMessage('‚ÑπÔ∏è Esta opera√ß√£o √© simulada - √≠ndices s√£o gerenciados automaticamente pelo Firestore', 'info');
        };
        
        // Fun√ß√£o para restaurar dados do backup
        window.restoreFromBackup = async function() {
            if (!confirm('üì• ATEN√á√ÉO: Esta opera√ß√£o ir√° restaurar dados do backup mais recente. Isso pode sobrescrever dados atuais. Continuar?')) {
                return;
            }
            
            logMessage('üì• Iniciando restaura√ß√£o do backup...', 'info');
            
            try {
                // Procurar pelo arquivo de backup mais recente
                const backupFiles = [
                    '[05-17]taskora_backup_2025-09-03.json',
                    'taskora_backup_latest.json',
                    'backup.json'
                ];
                
                let backupData = null;
                let usedFile = null;
                
                for (const fileName of backupFiles) {
                    try {
                        const response = await fetch(fileName);
                        if (response.ok) {
                            backupData = await response.json();
                            usedFile = fileName;
                            break;
                        }
                    } catch (error) {
                        console.log(`Arquivo ${fileName} n√£o encontrado`);
                    }
                }
                
                if (!backupData) {
                    logMessage('‚ùå Nenhum arquivo de backup encontrado', 'error');
                    return;
                }
                
                logMessage(`üìÅ Backup encontrado: ${usedFile}`, 'success');
                
                let totalRestored = 0;
                const collections = ['tasks', 'team', 'clients'];
                
                for (const collectionName of collections) {
                    if (backupData[collectionName] && Array.isArray(backupData[collectionName])) {
                        const batch = writeBatch(db);
                        let batchCount = 0;
                        
                        for (const item of backupData[collectionName]) {
                            if (item.id && item.data) {
                                // Verificar se o documento j√° existe
                                const docRef = doc(db, collectionName, item.id);
                                const docSnap = await getDoc(docRef);
                                
                                if (!docSnap.exists()) {
                                    // Restaurar apenas documentos que n√£o existem
                                    batch.set(docRef, item.data);
                                    batchCount++;
                                    totalRestored++;
                                    
                                    if (batchCount >= 500) {
                                        await batch.commit();
                                        batchCount = 0;
                                    }
                                }
                            }
                        }
                        
                        if (batchCount > 0) {
                            await batch.commit();
                        }
                        
                        logMessage(`‚úÖ ${collectionName}: ${backupData[collectionName].length} documentos processados`, 'info');
                    }
                }
                
                logMessage(`‚úÖ Restaura√ß√£o conclu√≠da: ${totalRestored} documentos restaurados`, 'success');
                
                // Executar nova an√°lise ap√≥s restaura√ß√£o
                setTimeout(deepAnalyzeData, 2000);
                
            } catch (error) {
                console.error('Erro na restaura√ß√£o:', error);
                logMessage(`‚ùå Erro na restaura√ß√£o: ${error.message}`, 'error');
            }
        };
        
        // Fun√ß√£o para limpeza nuclear
        window.nuclearCleanup = async function() {
            if (!confirm('‚ò¢Ô∏è ATEN√á√ÉO: Esta √© uma opera√ß√£o EXTREMAMENTE DESTRUTIVA que ir√° executar TODAS as corre√ß√µes de forma agressiva. Tem certeza?')) {
                return;
            }
            
            if (!confirm('‚ö†Ô∏è √öLTIMA CHANCE: Esta opera√ß√£o pode causar perda de dados. Voc√™ fez backup? Continuar mesmo assim?')) {
                return;
            }
            
            logMessage('‚ò¢Ô∏è Iniciando limpeza nuclear...', 'error');
            
            // Executar todas as opera√ß√µes em sequ√™ncia
            await forceFixDecimals();
            await normalizeAllTypes();
            await fixLegacyHours();
            await removeCorruptedData();
            await validateDataIntegrity();
            
            logMessage('‚ò¢Ô∏è Limpeza nuclear conclu√≠da!', 'success');
            document.getElementById('last-execution').textContent = new Date().toLocaleTimeString();
            
            // Executar nova an√°lise
            setTimeout(deepAnalyzeData, 2000);
        };
        
    </script>
</body>
</html>
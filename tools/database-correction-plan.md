# Plano de Corre√ß√£o do Banco de Dados - Taskora v5.5.5

## üéØ Objetivo
Corrigir os problemas identificados na migra√ß√£o de schema do Taskora, garantindo compatibilidade entre dados legados e nova estrutura, sem perda de dados e com m√≠nimo impacto na opera√ß√£o.

---

## üìã Resumo Executivo

### **Problemas Identificados:**
- ‚úÖ **6 categorias cr√≠ticas** de incompatibilidade
- ‚úÖ **Dados corrompidos** com n√∫meros decimais longos
- ‚úÖ **Refer√™ncias quebradas** entre cole√ß√µes
- ‚úÖ **Tipos de dados inconsistentes** (Timestamp vs String)
- ‚úÖ **Campos obrigat√≥rios ausentes** em dados legados
- ‚úÖ **Performance degradada** por queries sem √≠ndices

### **Estrat√©gia:**
1. **Corre√ß√£o imediata** de problemas cr√≠ticos
2. **Migra√ß√£o gradual** para nova estrutura
3. **Manuten√ß√£o de compatibilidade** com dados legados
4. **Monitoramento cont√≠nuo** da integridade

---

## üöÄ Fase 1: Corre√ß√µes Cr√≠ticas Imediatas (1-2 dias)

### **1.1 Corre√ß√£o de N√∫meros Decimais Longos**
**Prioridade:** üî¥ CR√çTICA  
**Tempo estimado:** 4 horas  
**Risco:** Baixo

**A√ß√µes:**
1. ‚úÖ Criar ferramenta `fix-decimal-precision.html`
2. ‚úÖ Executar corre√ß√£o em cole√ß√£o `team` (campo `totalHours`)
3. ‚è≥ Executar corre√ß√£o em cole√ß√£o `tasks` (campo `hours`)
4. ‚è≥ Executar corre√ß√£o em cole√ß√£o `clients` (campos de or√ßamento)
5. ‚è≥ Atualizar c√≥digo para arredondamento autom√°tico

**C√≥digo de Corre√ß√£o:**
```javascript
// Implementar em todos os reposit√≥rios
function roundToDecimals(num, decimals = 2) {
  return Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals);
}

// Aplicar em todos os c√°lculos
function calculateTotalHours(tasks) {
  const total = tasks.reduce((sum, task) => sum + (task.hours || 0), 0);
  return roundToDecimals(total, 2);
}
```

**Arquivos a Modificar:**
- `assets/js/data/tasksRepo.js`
- `assets/js/data/clientsRepo.js`
- `assets/js/data/teamRepo.js`
- `assets/js/pages/team.js`

---

### **1.2 Corre√ß√£o de Refer√™ncias Quebradas**
**Prioridade:** üî¥ CR√çTICA  
**Tempo estimado:** 6 horas  
**Risco:** M√©dio

**Problema:** Tasks com `clientRef` apontando para clientes inexistentes

**A√ß√µes:**
1. ‚è≥ Identificar todas as refer√™ncias quebradas
2. ‚è≥ Criar clientes ausentes automaticamente
3. ‚è≥ Implementar fallback robusto no c√≥digo
4. ‚è≥ Adicionar valida√ß√£o antes de salvar

**Estrat√©gia de Corre√ß√£o:**
```javascript
// 1. Identificar refer√™ncias quebradas
async function findBrokenReferences() {
  const tasks = await getDocs(collection(db, 'tasks'));
  const brokenRefs = [];
  
  for (const task of tasks.docs) {
    const data = task.data();
    if (data.clientRef) {
      try {
        const clientDoc = await getDoc(data.clientRef);
        if (!clientDoc.exists()) {
          brokenRefs.push({ taskId: task.id, clientRef: data.clientRef });
        }
      } catch (error) {
        brokenRefs.push({ taskId: task.id, error: error.message });
      }
    }
  }
  
  return brokenRefs;
}

// 2. Corrigir refer√™ncias quebradas
async function fixBrokenReferences(brokenRefs) {
  for (const ref of brokenRefs) {
    // Criar cliente padr√£o ou converter para string
    const defaultClient = await createClient({
      name: 'Cliente Migrado',
      status: 'ATIVO',
      tier: 'MID_TIER'
    });
    
    // Atualizar task com nova refer√™ncia
    await updateDoc(doc(db, 'tasks', ref.taskId), {
      clientRef: defaultClient
    });
  }
}
```

---

### **1.3 Implementa√ß√£o de Fallbacks Robustos**
**Prioridade:** üî¥ CR√çTICA  
**Tempo estimado:** 4 horas  
**Risco:** Baixo

**A√ß√µes:**
1. ‚è≥ Atualizar `mapDbToUi()` com fallbacks
2. ‚è≥ Atualizar `mapUiToDb()` com valida√ß√£o
3. ‚è≥ Implementar tratamento de erros robusto
4. ‚è≥ Adicionar logs detalhados

**C√≥digo de Fallback:**
```javascript
// tasksRepo.js - mapDbToUi() robusto
function mapDbToUi(docSnap) {
  const data = docSnap.data();
  
  return {
    id: docSnap.id,
    orgId: data.orgId || 'dacora',
    
    // Cliente - m√∫ltiplos fallbacks
    client: data.client || 
            data.clientRef?.displayName || 
            'Cliente n√£o informado',
            
    // Respons√°vel - m√∫ltiplos fallbacks
    owner: data.owner || 
           data.assigneeRef?.name || 
           'N√£o atribu√≠do',
           
    // Horas - com arredondamento
    hours: roundToDecimals(
      data.hours || 
      (data.spentMinutes ? data.spentMinutes / 60 : 0), 
      2
    ),
    
    // Datas - compatibilidade bidirecional
    date: data.date || 
          (data.startAt ? formatDate(data.startAt) : ''),
    dueDate: data.dueDate || 
             (data.dueAt ? formatDate(data.dueAt) : ''),
             
    // Status - normaliza√ß√£o
    status: normalizeStatus(data.status || 'n√£o realizada'),
    
    // Timestamps com fallback
    createdAt: data.createdAt || new Date(),
    updatedAt: data.updatedAt || data.createdAt || new Date()
  };
}
```

---

## üîß Fase 2: Corre√ß√µes de Compatibilidade (3-5 dias)

### **2.1 Normaliza√ß√£o de Tipos de Data**
**Prioridade:** üü° ALTA  
**Tempo estimado:** 8 horas  
**Risco:** M√©dio

**Problema:** Mistura de `Timestamp` e `string` para datas

**Estrat√©gia:**
1. ‚è≥ Manter campos legados como `string`
2. ‚è≥ Adicionar campos novos como `Timestamp`
3. ‚è≥ Implementar sincroniza√ß√£o bidirecional
4. ‚è≥ Migrar gradualmente conforme uso

**Mapeamento de Campos:**
```javascript
// Estrat√©gia de coexist√™ncia
const dateFieldMapping = {
  // Legado (manter como string)
  'date': 'string',        // YYYY-MM-DD
  'dueDate': 'string',     // YYYY-MM-DD
  
  // Novo (adicionar como Timestamp)
  'startAt': 'Timestamp',  // Para filtros e ordena√ß√£o
  'dueAt': 'Timestamp',    // Para filtros e ordena√ß√£o
  'reminderAt': 'Timestamp', // Para notifica√ß√µes
  
  // Controle (sempre Timestamp)
  'createdAt': 'Timestamp',
  'updatedAt': 'Timestamp'
};
```

---

### **2.2 Migra√ß√£o de Cole√ß√£o Clients**
**Prioridade:** üü° ALTA  
**Tempo estimado:** 6 horas  
**Risco:** Alto

**Problema:** Cole√ß√£o `clients` pode n√£o existir ou estar incompleta

**A√ß√µes:**
1. ‚è≥ Extrair clientes √∫nicos das tasks existentes
2. ‚è≥ Criar registros na cole√ß√£o `clients`
3. ‚è≥ Atualizar refer√™ncias nas tasks
4. ‚è≥ Validar integridade das refer√™ncias

**Script de Migra√ß√£o:**
```javascript
async function migrateClientsFromTasks() {
  // 1. Extrair clientes √∫nicos das tasks
  const tasks = await getDocs(collection(db, 'tasks'));
  const uniqueClients = new Set();
  
  tasks.docs.forEach(doc => {
    const data = doc.data();
    if (data.client && typeof data.client === 'string') {
      uniqueClients.add(data.client);
    }
  });
  
  // 2. Criar registros de clientes
  const clientRefs = new Map();
  
  for (const clientName of uniqueClients) {
    const clientData = {
      orgId: 'dacora',
      displayName: clientName,
      status: 'ATIVO',
      tier: 'MID_TIER',
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    };
    
    const clientRef = await addDoc(collection(db, 'clients'), clientData);
    clientRefs.set(clientName, clientRef);
  }
  
  // 3. Atualizar tasks com refer√™ncias
  for (const taskDoc of tasks.docs) {
    const data = taskDoc.data();
    if (data.client && typeof data.client === 'string') {
      const clientRef = clientRefs.get(data.client);
      if (clientRef) {
        await updateDoc(doc(db, 'tasks', taskDoc.id), {
          clientRef: clientRef,
          // Manter campo original para compatibilidade
          client: data.client
        });
      }
    }
  }
}
```

---

### **2.3 Otimiza√ß√£o de Performance**
**Prioridade:** üü° ALTA  
**Tempo estimado:** 4 horas  
**Risco:** Baixo

**A√ß√µes:**
1. ‚è≥ Simplificar queries complexas
2. ‚è≥ Implementar pagina√ß√£o eficiente
3. ‚è≥ Adicionar cache em mem√≥ria
4. ‚è≥ Documentar √≠ndices necess√°rios

**Otimiza√ß√µes:**
```javascript
// Antes: Query complexa sem √≠ndice
const complexQuery = query(tasksRef,
  where('orgId', '==', 'dacora'),
  where('status', '==', 'em progresso'),
  where('assigneeRef', '==', userRef),
  orderBy('dueAt', 'desc')
);

// Depois: Query simples + filtro em mem√≥ria
const simpleQuery = query(tasksRef,
  where('orgId', '==', 'dacora'),
  orderBy('createdAt', 'desc'),
  limit(100)
);

const tasks = await getDocs(simpleQuery);
const filteredTasks = tasks.docs
  .map(doc => ({ id: doc.id, ...doc.data() }))
  .filter(task => task.status === 'em progresso')
  .filter(task => task.owner === userName)
  .slice(0, 20); // Pagina√ß√£o
```

---

## üîç Fase 3: Valida√ß√£o e Monitoramento (2-3 dias)

### **3.1 Implementa√ß√£o de Valida√ß√£o**
**Prioridade:** üü¢ M√âDIA  
**Tempo estimado:** 6 horas  
**Risco:** Baixo

**A√ß√µes:**
1. ‚è≥ Criar schemas de valida√ß√£o
2. ‚è≥ Implementar valida√ß√£o antes de salvar
3. ‚è≥ Adicionar testes automatizados
4. ‚è≥ Criar relat√≥rios de integridade

**Schema de Valida√ß√£o:**
```javascript
const taskSchema = {
  orgId: { type: 'string', required: true, default: 'dacora' },
  title: { type: 'string', required: true, minLength: 1 },
  status: { type: 'string', enum: ['n√£o realizada', 'em progresso', 'conclu√≠da', 'cancelada'] },
  hours: { type: 'number', min: 0, max: 24, decimals: 2 },
  client: { type: 'string', required: true },
  owner: { type: 'string', required: true },
  date: { type: 'string', pattern: /^\d{4}-\d{2}-\d{2}$/ },
  createdAt: { type: 'Timestamp', required: true },
  updatedAt: { type: 'Timestamp', required: true }
};

function validateTask(taskData) {
  const errors = [];
  
  for (const [field, rules] of Object.entries(taskSchema)) {
    const value = taskData[field];
    
    // Verificar campos obrigat√≥rios
    if (rules.required && (value === undefined || value === null || value === '')) {
      if (rules.default !== undefined) {
        taskData[field] = rules.default;
      } else {
        errors.push(`Campo obrigat√≥rio ausente: ${field}`);
      }
    }
    
    // Verificar tipos
    if (value !== undefined && rules.type) {
      if (rules.type === 'number' && typeof value !== 'number') {
        errors.push(`Campo ${field} deve ser n√∫mero`);
      }
      if (rules.type === 'string' && typeof value !== 'string') {
        errors.push(`Campo ${field} deve ser string`);
      }
    }
    
    // Verificar decimais
    if (rules.decimals && typeof value === 'number') {
      taskData[field] = roundToDecimals(value, rules.decimals);
    }
  }
  
  return { isValid: errors.length === 0, errors, data: taskData };
}
```

---

### **3.2 Sistema de Monitoramento**
**Prioridade:** üü¢ M√âDIA  
**Tempo estimado:** 4 horas  
**Risco:** Baixo

**A√ß√µes:**
1. ‚è≥ Implementar logs estruturados
2. ‚è≥ Criar dashboard de integridade
3. ‚è≥ Configurar alertas autom√°ticos
4. ‚è≥ Implementar m√©tricas de performance

**Sistema de Logs:**
```javascript
class DatabaseLogger {
  static log(level, operation, data, error = null) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      level: level, // INFO, WARN, ERROR
      operation: operation, // CREATE, UPDATE, DELETE, QUERY
      collection: data.collection,
      documentId: data.documentId,
      userId: data.userId || 'system',
      error: error ? error.message : null,
      metadata: data.metadata || {}
    };
    
    console.log(`[${level}] ${operation}:`, logEntry);
    
    // Enviar para sistema de monitoramento externo
    if (level === 'ERROR') {
      this.sendAlert(logEntry);
    }
  }
  
  static sendAlert(logEntry) {
    // Implementar notifica√ß√£o para problemas cr√≠ticos
    console.error('ALERTA CR√çTICO:', logEntry);
  }
}

// Uso nos reposit√≥rios
async function createTask(taskData) {
  try {
    const validation = validateTask(taskData);
    if (!validation.isValid) {
      DatabaseLogger.log('ERROR', 'CREATE', {
        collection: 'tasks',
        metadata: { validationErrors: validation.errors }
      });
      throw new Error(`Dados inv√°lidos: ${validation.errors.join(', ')}`);
    }
    
    const docRef = await addDoc(collection(db, 'tasks'), validation.data);
    
    DatabaseLogger.log('INFO', 'CREATE', {
      collection: 'tasks',
      documentId: docRef.id,
      metadata: { title: taskData.title }
    });
    
    return docRef;
  } catch (error) {
    DatabaseLogger.log('ERROR', 'CREATE', {
      collection: 'tasks',
      metadata: { taskData }
    }, error);
    throw error;
  }
}
```

---

## üìä Fase 4: Ferramentas de Manuten√ß√£o (1-2 dias)

### **4.1 Ferramenta de Diagn√≥stico Avan√ßado**
**Prioridade:** üü¢ M√âDIA  
**Tempo estimado:** 4 horas

**A√ß√µes:**
1. ‚è≥ Expandir `database-schema-analyzer.html`
2. ‚è≥ Adicionar relat√≥rios detalhados
3. ‚è≥ Implementar corre√ß√µes autom√°ticas
4. ‚è≥ Criar interface de administra√ß√£o

---

### **4.2 Scripts de Backup e Restore**
**Prioridade:** üü¢ M√âDIA  
**Tempo estimado:** 3 horas

**A√ß√µes:**
1. ‚è≥ Criar script de backup completo
2. ‚è≥ Implementar restore seletivo
3. ‚è≥ Adicionar versionamento de dados
4. ‚è≥ Testar procedimentos de recupera√ß√£o

---

## üìÖ Cronograma de Execu√ß√£o

### **Semana 1 (Dias 1-2): Corre√ß√µes Cr√≠ticas**
- **Dia 1 Manh√£:** Corre√ß√£o de n√∫meros decimais
- **Dia 1 Tarde:** Implementa√ß√£o de fallbacks
- **Dia 2 Manh√£:** Corre√ß√£o de refer√™ncias quebradas
- **Dia 2 Tarde:** Testes e valida√ß√£o

### **Semana 1 (Dias 3-5): Compatibilidade**
- **Dia 3:** Normaliza√ß√£o de tipos de data
- **Dia 4:** Migra√ß√£o de cole√ß√£o clients
- **Dia 5:** Otimiza√ß√£o de performance

### **Semana 2 (Dias 1-3): Valida√ß√£o**
- **Dia 1-2:** Implementa√ß√£o de valida√ß√£o
- **Dia 3:** Sistema de monitoramento

### **Semana 2 (Dias 4-5): Ferramentas**
- **Dia 4:** Ferramentas de diagn√≥stico
- **Dia 5:** Scripts de backup e testes finais

---

## ‚ö†Ô∏è Riscos e Mitiga√ß√µes

### **Riscos Identificados:**
1. **Perda de dados** durante corre√ß√µes
   - **Mitiga√ß√£o:** Backup completo antes de cada fase
   
2. **Downtime da aplica√ß√£o**
   - **Mitiga√ß√£o:** Corre√ß√µes em hor√°rios de baixo uso
   
3. **Incompatibilidade com dados existentes**
   - **Mitiga√ß√£o:** Manter compatibilidade bidirecional
   
4. **Performance degradada** durante migra√ß√£o
   - **Mitiga√ß√£o:** Processamento em lotes pequenos

### **Plano de Rollback:**
1. **Backup autom√°tico** antes de cada corre√ß√£o
2. **Versionamento** de schemas
3. **Scripts de revers√£o** para cada mudan√ßa
4. **Monitoramento** em tempo real durante execu√ß√£o

---

## ‚úÖ Crit√©rios de Sucesso

### **M√©tricas de Qualidade:**
- ‚úÖ **0 n√∫meros decimais longos** (>2 casas)
- ‚úÖ **0 refer√™ncias quebradas** em tasks
- ‚úÖ **100% das tasks** com campos obrigat√≥rios
- ‚úÖ **<2s tempo de carregamento** para listagens
- ‚úÖ **0 erros JavaScript** relacionados a dados

### **Funcionalidades Validadas:**
- ‚úÖ **Listagem de tarefas** funciona corretamente
- ‚úÖ **Cria√ß√£o de tarefas** salva dados v√°lidos
- ‚úÖ **Filtros** funcionam com dados migrados
- ‚úÖ **Relat√≥rios** exibem valores corretos
- ‚úÖ **Sincroniza√ß√£o Team ‚Üî Tasks** operacional

---

## üöÄ Pr√≥ximos Passos Imediatos

1. ‚úÖ **Executar backup completo** do Firebase
2. ‚è≥ **Implementar corre√ß√£o de n√∫meros decimais**
3. ‚è≥ **Testar corre√ß√µes** em ambiente de desenvolvimento
4. ‚è≥ **Aplicar corre√ß√µes** em produ√ß√£o (hor√°rio de baixo uso)
5. ‚è≥ **Monitorar** integridade dos dados p√≥s-corre√ß√£o

---

*Plano criado em: Janeiro 2025*  
*Vers√£o: 1.0*  
*Status: Pronto para execu√ß√£o*